import numpy as np
import pandas as pd
import matplotlib.pyplot as pp
from sklearn.linear_model import LinearRegression
import pickle

fig,axs=pp.subplots(1, 1, figsize=(14,8), sharey='row')

densities=['sample441.pickle', 'sample361.pickle', 'sample114.pickle']





#
#  density 441
#

sets_loaded={}
for p in densities:
    with open(p, 'rb') as f:
        sets_loaded[p]=pickle.load(f)

dfs=sets_loaded['sample441.pickle']

preload_axs={#6: {'ax':axs, 'plotargs':{'c':'b'}         }, 
            #12: {'ax':axs, 'plotargs':{'c':'k'}         },
            #18: {'ax':axs, 'plotargs':{'c':'r'}         }, 
            #24: {'ax':axs, 'plotargs':{'c':'g'}         },
            30: {'ax':axs, 'plotargs':{'c':'gray'}      },  
            #36: {'ax':axs, 'plotargs':{'c':'m'}         },
            #42: {'ax':axs, 'plotargs':{'c':'y'}         }
            }


def chop_retraction(retraction, ):
    # slice the curve so we'll just have the interesting part to us
    diffs=np.diff(retraction['Normal Force'])
    sth_diffs=np.convolve(diffs, np.ones(5)/5, mode='same')

    adh_idx=np.min(np.where(np.abs(sth_diffs[:])<0.001))
    adh_idx_last=adh_idx+np.min(np.where(np.max(sth_diffs[adh_idx:])==sth_diffs[adh_idx:]))+3
    
    cpd_ret=retraction.iloc[adh_idx:adh_idx_last]
    return cpd_ret

def ret2adh(cpd_ret, L_c, A_att, N_att):

    adhesion=pd.DataFrame()
    
    adhesion['lambda']=1e-3 * (  cpd_ret.loc[:,'Gap']-cpd_ret.iloc[0,0] )/ L_c # in m/m, thus unitless
    adhesion['F_mushroom']=( -(cpd_ret['Normal Force']-cpd_ret.iloc[0,1])/N_att ) # in N/mush
    adhesion['sigma']=( -(cpd_ret.loc[:,'Normal Force']-cpd_ret.iloc[0,1])/N_att/A_att ) # in Pa/mush

    return(adhesion)


def stretch_modulus(adhesion, A_att, lims=(150,300)):
    lmbd=np.array(adhesion['lambda'].iloc[lims[0]:lims[1]])
    sigma=np.array(adhesion['sigma'].iloc[lims[0]:lims[1]])
    reg = LinearRegression().fit(lmbd.reshape(-1,1), sigma) 
    E=reg.coef_*A_att
    return E 

def cor_frc_finexp(adhesion, E, L_c, L_m, N_att):
    print(locals())
    W=L_m/L_c
    cor_frc=pd.DataFrame()
    cor_frc['lambda.E']= adhesion['lambda']*float(E)
    cor_frc['sigma_deexp']= adhesion['F_mushroom']/(float(E)*adhesion['lambda']*(1-np.exp(-adhesion['lambda']/W)))
    cor_frc['log1sigma']= -np.log( cor_frc['sigma_deexp']  )
    cor_frc['log2lambda']= np.log( cor_frc['lambda.E'] )
    cor_frc['log2sigma']= np.log( cor_frc['log1sigma'] )

    return(cor_frc)

A_total=0.025**2
retractions={}
cpd_ret={}
fits={}
adhesion={}
pars={}
cor_frc={}
for preload in [preload for preload in preload_axs if np.any( dfs[preload]['N_attached'] )]:
    pars[preload]={}

    # only load preloads that have N_attached specified, ignore the rest
    retractions[preload]={i/5: dfs[preload]['intervals'][i]['data'].loc[:,['Gap', 'Normal Force']] \
            for i in range(5,30,5)}

    pars[preload]['A_att']={ret: A_total*dfs[preload]['N_attached'].iloc[0,int(ret-1)]/dfs[preload]['N_total'] 
            for ret in retractions[preload]}

    # find the relevant region
    cpd_ret[preload]={ret: chop_retraction(retractions[preload][ret]) for ret in retractions[preload]}
    # transform to sigma_adhesion vs. strain
    adhesion[preload]={ret: ret2adh(cpd_ret[preload][ret], float(dfs[preload]['L_c']),  \
            pars[preload]['A_att'][ret], dfs[preload]['N_attached'].iloc[0,int(ret-1)] ) 
            for ret in cpd_ret[preload]}
    # obtain modulus level
    pars[preload]['moduli']={ret: stretch_modulus(adhesion[preload][ret],  \
            pars[preload]['A_att'][ret]) for ret in cpd_ret[preload]  }
    cor_frc[preload]={ret: cor_frc_finexp(adhesion[preload][ret], pars[preload]['moduli'][ret], 
            float(dfs[preload]['L_c']), float(dfs[preload]['L_m']),  
            dfs[preload]['N_attached'].iloc[0,int(ret-1)] ) 
            for ret in retractions[preload]  }
  
for preload in cor_frc:
    fig, ax=pp.subplots(figsize=(8,6))
    fig2, ax2=pp.subplots(figsize=(8,6))
    [ax.plot( cor_frc[preload][ret]['log2lambda'], cor_frc[preload][ret]['log2sigma'], marker='o', ms=3  ) for ret in cor_frc[preload]]
    [ax2.plot( cpd_ret[preload][ret]['Gap'], cpd_ret[preload][ret]['Normal Force'], marker='o', ms=3  ) for ret in cor_frc[preload]]


# axs.set_ylim((-0.5,0.1))
# axs.set_xlabel('$d$ (mm)')
# axs.set_ylabel('$F$ (N)')
# fig.tight_layout()
# fig.savefig('Sample441.pdf')
# 



